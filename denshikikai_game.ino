#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <stdio.h>
// #include <new.h> //new,deleteのライブラリ

// Adafruit_SSD1306 display型変数の宣言
#define SCREEN_WIDTH 128    // OLED display width, in pixels
#define SCREEN_HEIGHT 64    // OLED display height, in pixels
#define OLED_RESET -1       // Reset pin # (or -1 if sharing Arduino reset pin)
#define SCREEN_ADDRESS 0x3C //< See datasheet for Address; 0x3C for 128x32
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

#define pinX A0
#define pinY A1

#define DefaultCursorY 9

#define MaxBullets 16 // 弾の最大生成数
#define DefaultHealth 3

// 周期処理のタイマー初期設定　////////////////////////////////////////////https://qiita.com/Ninagawa123/items/f8585c5c711bcf065656
// https://qiita.com/Ninagawa123/items/f8585c5c711bcf065656
const uint8_t frame_ms = 50; // 1フレームあたりの単位時間(ms)
unsigned long sframe;        // フレーム管理時計の時刻 schaduledなflame数
unsigned long frameCounter;

int stickX, stickY;
uint16_t score = 0;
// スコア加算
void addScore(int value)
{
  score += value;
}

uint16_t bestScore = 0;

// bool inGameNow = true;
// bool inGameStartFlag = false;

#define inTitle 0
#define inGameStart 1
#define inGameNow 2
#define inGameEnd 3
#define inResult 4

uint8_t gameState = inTitle;

int8_t xStickState = 0, yStickState = 0; //-2のとき負方向大、-1のとき負方向小、0のとき中心、1のとき正方向小、2のとき正方向大

// uint8_t pixelsBuffer[128][54] = {{0}}; //画素のバッファ

uint8_t bulletNumber = 0; // 弾番号のメモリを確保

// 弾のクラス
class BulletClass
{
private:
  int8_t posX;
  float posY;
  int8_t speedX;
  int8_t speedY;

  void move()
  { // 弾を動かす関数
    if (isActive)
    {
      posX = posX - speedX;                    // x座標
      posY = posY + ((float)(speedY) / 100.0); // y座標
      if (posX < 0 || posY < 0 || posY > 54)
      {
        isActive = false; // 画面の範囲外に出たら弾を無効に

        if (gameState == inGameNow)
        { // ゲーム中にのみスコア加算
          addScore(10);
        }
      }
    }
  }
  void write()
  {
    // if(!pixelsBuffer[(uint8_t)posX][(uint8_t)posY]){
    //   pixelsBuffer[(uint8_t)posX][(uint8_t)posY] += 1;
    // }

    display.drawPixel(posX, posY + DefaultCursorY, WHITE); // ディスプレイバッファに書き込み
  }

public:
  bool isActive = false; // 表示されている弾かどうか
  void activateBullet()
  { // 弾の有効化
    posX = 127;
    posY = (float)random(5, 50);
    speedX = random(2, 4);
    speedY = (int8_t)random(-50, 50);
    isActive = true;
  }
  void update()
  { // 弾の処理
    if (isActive == true)
    { // 弾が有効のときのみ処理
      move();
      write();
    }
  }
  int8_t returnPosX()
  { // 弾のx座標を返す
    return posX;
  }
  int8_t returnPosY()
  {                      // 弾のy座標を返す
    return (int8_t)posY; // 整数型にキャスト
  }
};

// 弾の生成
BulletClass bullet[MaxBullets];

class PlayerClass
{
private:
  int8_t posX;
  int8_t posY;
  uint8_t onDamagedCounter = 0;
  bool isVisible = false; // 描画するかどうか

public:
  int8_t health; // 体力
  void start()
  { // プレイヤー座標と体力初期化
    posX = 8;
    posY = 27;
    health = DefaultHealth;
    isVisible = true;
  }
  void move()
  { // プレイヤーを動かす
    posX = posX + xStickState;
    if (posX < 2 || posX > 124)
    { // 画面外に出ないように座標を戻す
      posX = posX - xStickState;
    }
    posY = posY - yStickState; // ディスプレイはy軸正方向が下向きなのでマイナスの入力を正に変換
    if (posY < 1 || posY > 53)
    {
      posY = posY + yStickState;
    }
  }

  // 当たり判定
  void hit()
  {
    for (uint8_t cnt = 0; cnt < MaxBullets; cnt++)
    { // すべての弾に対して検索
      // 自機スプライトの範囲に弾がいるとき
      if (posX - 2 <= bullet[cnt].returnPosX() && bullet[cnt].returnPosX() <= posX + 2 && posY - 1 <= bullet[cnt].returnPosY() && bullet[cnt].returnPosY() <= posY + 1)
      {
        bullet[cnt].isActive = false;
        if (onDamagedCounter == 0)
        { // ダメージを受けてから一定フレーム経っているとき
          health--;
          onDamagedCounter = 40; // 指定フレーム数が経過するまでダメージを受けない
          if (health == 0)
          {
            onDamagedCounter = 60;
            gameState = inGameEnd;
          }
        }
      }
    }
  }
  void damageAnimator()
  { // ダメージ時のアニメーション
    if (onDamagedCounter > 18)
    {
      if (((onDamagedCounter + 2) % 6) == 0)
      {
        isVisible = false; // カウンタが42,36,30,24のとき非表示
      }
      else if (((onDamagedCounter + 2) % 3) == 0)
      {
        isVisible = true; // カウンタが39,33,27,21のとき表示
      }
    }
  }
  void update()
  {
    move();
    hit();
    damageAnimator();
    if (onDamagedCounter > 0)
    {
      onDamagedCounter--;
    }
    write();
    // display.setCursor(0,56);
    // display.print(isVisible);デバッグ用
  }
  void write()
  {
    if (isVisible == true)
    { // 描画が有効のとき
      // 自機のグラフィックを左上から順にドット打ち
      display.drawPixel(posX - 2, posY + 1 + DefaultCursorY, WHITE); // ディスプレイバッファに書き込み
      display.drawPixel(posX - 2, posY + DefaultCursorY, WHITE);     // ディスプレイバッファに書き込み
      display.drawPixel(posX - 2, posY - 1 + DefaultCursorY, WHITE); // ディスプレイバッファに書き込み
      display.drawPixel(posX - 1, posY + 1 + DefaultCursorY, WHITE); // ディスプレイバッファに書き込み
      display.drawPixel(posX - 1, posY - 1 + DefaultCursorY, WHITE); // ディスプレイバッファに書き込み
      display.drawPixel(posX, posY + 1 + DefaultCursorY, WHITE);     // ディスプレイバッファに書き込み
      display.drawPixel(posX, posY - 1 + DefaultCursorY, WHITE);     // ディスプレイバッファに書き込み
      display.drawPixel(posX + 1, posY + 1 + DefaultCursorY, WHITE); // ディスプレイバッファに書き込み
      display.drawPixel(posX + 1, posY - 1 + DefaultCursorY, WHITE); // ディスプレイバッファに書き込み
      display.drawPixel(posX + 2, posY + DefaultCursorY, WHITE);     // ディスプレイバッファに書き込み
    }
  }
  void particle(int x, int y)
  { // 終了時アニメーション
    if ((x < 0 || x > 125 || y < 0 || y > 54) == false)
    {
      display.drawPixel(x, y + DefaultCursorY, WHITE);
    }
  }
  void endAnimator()
  { // healthが0になったとき
    if (onDamagedCounter % 3 || onDamagedCounter % 4)
    {
      particle((int)posX + 2 * (60 - onDamagedCounter), (int)posY);
      particle((int)posX - 2 * (60 - onDamagedCounter), (int)posY);
      particle((int)posX, (int)posY + 2 * (60 - onDamagedCounter));
      particle((int)posX, (int)posY - 2 * (60 - onDamagedCounter));
      particle((int)((float)posX + 1.41 * (60 - onDamagedCounter)), (int)((float)posY + 1.41 * (60 - onDamagedCounter)));
      particle((int)((float)posX + 1.41 * (60 - onDamagedCounter)), (int)((float)posY - 1.41 * (60 - onDamagedCounter)));
      particle((int)((float)posX - 1.41 * (60 - onDamagedCounter)), (int)((float)posY + 1.41 * (60 - onDamagedCounter)));
      particle((int)((float)posX - 1.41 * (60 - onDamagedCounter)), (int)((float)posY - 1.41 * (60 - onDamagedCounter)));
    }
    if (onDamagedCounter == 57 || onDamagedCounter == 53)
    {
      display.invertDisplay(false);
    }
    else if (onDamagedCounter == 59 || onDamagedCounter == 55)
    {
      display.invertDisplay(true);
    }
    onDamagedCounter--;
    if (onDamagedCounter == 0)
    {
      gameState = inResult;
      frameCounter = 20;
      if (score > bestScore)
      {
        bestScore = score;
      }
    }
  }
};

PlayerClass player;

// タイトル/リザルト画面の背景
//  'background', 128x64px
const unsigned char titlebgbackground[] PROGMEM = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0x83, 0xff, 0xff, 0xff, 0xff,
    0x07, 0xf8, 0x30, 0x0c, 0x1f, 0xe0, 0xc1, 0xfe, 0x00, 0x0f, 0xf0, 0x00, 0x1f, 0xff, 0xff, 0xff,
    0x0f, 0xfc, 0x38, 0x1c, 0x3f, 0xf0, 0xe1, 0xff, 0x80, 0x1f, 0x80, 0x00, 0x07, 0xff, 0xff, 0xff,
    0x1b, 0xfe, 0x6c, 0x3e, 0x6f, 0xf9, 0x73, 0x7f, 0xc0, 0x3f, 0x00, 0x38, 0x03, 0xff, 0xff, 0xff,
    0x17, 0xfe, 0x5c, 0x3e, 0x5f, 0xf9, 0x72, 0xff, 0xc0, 0x7f, 0x07, 0xff, 0xc3, 0xff, 0xff, 0xff,
    0x17, 0xfe, 0x5c, 0x3e, 0x5c, 0xf9, 0x72, 0xcf, 0xc0, 0xff, 0x1f, 0xff, 0xf3, 0xff, 0xff, 0xff,
    0x1f, 0x3e, 0x7c, 0x3e, 0x78, 0x79, 0xf3, 0xc3, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0x1e, 0x1e, 0x7c, 0x3e, 0x78, 0x79, 0xf3, 0xc3, 0xc1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0x1e, 0x1e, 0x7c, 0x3e, 0x78, 0x79, 0xf3, 0xc3, 0xc3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0x1f, 0x3e, 0x7c, 0x3e, 0x78, 0x79, 0xf3, 0xc3, 0xc3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0x1f, 0xfe, 0x7e, 0x7e, 0x78, 0x79, 0xf3, 0xc3, 0xc7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0x1f, 0xfe, 0x7f, 0xfe, 0x78, 0x79, 0xf3, 0xc3, 0xcf, 0xff, 0xff, 0x87, 0xff, 0xff, 0x80, 0x0f,
    0x1f, 0xfe, 0x7f, 0xfe, 0x78, 0x79, 0xf3, 0xc3, 0xcf, 0xff, 0xff, 0x03, 0xff, 0xfc, 0x00, 0x01,
    0x1f, 0xfe, 0x3f, 0xfc, 0x78, 0x79, 0xf3, 0xc3, 0xdf, 0xff, 0xfe, 0x01, 0xff, 0xf8, 0x00, 0x00,
    0x1f, 0xfe, 0x1f, 0xd8, 0x7c, 0xf9, 0xf3, 0xcf, 0xdf, 0xff, 0xfc, 0x01, 0xff, 0xf8, 0x18, 0x30,
    0x1f, 0x3a, 0x0f, 0xb0, 0x7f, 0xe9, 0xd3, 0xff, 0x7f, 0xff, 0xfc, 0x00, 0xff, 0xf8, 0xf0, 0x1c,
    0x1e, 0x16, 0x07, 0xe0, 0x7f, 0xd9, 0xb3, 0xfe, 0xff, 0xff, 0xfc, 0x00, 0xff, 0xff, 0xe0, 0x1e,
    0x0e, 0x1c, 0x03, 0xc0, 0x3f, 0xf0, 0xe1, 0xff, 0xff, 0xff, 0xfc, 0x00, 0xff, 0xff, 0xe0, 0x1f,
    0x06, 0x18, 0x01, 0x80, 0x1f, 0xe0, 0xc1, 0xfe, 0x7f, 0xff, 0xfc, 0x00, 0xff, 0xff, 0xc0, 0x0f,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xfc, 0x00, 0xff, 0xff, 0xc0, 0x0f,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xfe, 0x01, 0xff, 0xff, 0xc0, 0x0f,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x03, 0xff, 0xff, 0xc0, 0x0f,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x87, 0xff, 0xff, 0xe0, 0x1f,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x1f,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x3f,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xc7, 0xff, 0xff, 0xff, 0xff, 0xff,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xff,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x7e, 0xfe, 0x00, 0x3f, 0xff, 0xff,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x7f, 0x7c, 0x00, 0x07, 0xff, 0xff,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x7f, 0xfe, 0x00, 0x01, 0xff, 0xff,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xbf, 0xff, 0x00, 0x7f, 0xff,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x3f, 0xff,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xbf, 0xdf, 0xff, 0xfc, 0x1f, 0xff,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xbf, 0xdf, 0xff, 0xff, 0x0f, 0xff,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xbf, 0xef, 0xff, 0xff, 0x9f, 0xff,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xbf, 0xef, 0xff, 0xff, 0xff, 0xff,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xef, 0xff, 0xff, 0xff, 0xff,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xdf, 0xff, 0xff, 0xf8, 0xff,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0x7f, 0xdf, 0xff, 0xff, 0x8f, 0x7f,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xdf, 0xff, 0xf0, 0xff, 0xff,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xfe, 0xff, 0xbf, 0xff, 0x1f, 0xff, 0xbf,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xfd, 0xff, 0x7f, 0xf1, 0xff, 0xff, 0xbf,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xfb, 0xff, 0x7f, 0x1f, 0xff, 0xff, 0xbf,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf7, 0xfe, 0xf1, 0xff, 0xff, 0xff, 0xff,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xef, 0xff, 0x3f, 0xff, 0xff, 0xff, 0x7f,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xdf, 0xff, 0xff, 0xff, 0xff, 0xf1, 0xff,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0x1f, 0xff,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xf1, 0xff, 0xff,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0x1f, 0xff, 0xff};

// Array of all bitmaps for convenience. (Total bytes used to store images in PROGMEM = 1040)
const int titlebgallArray_LEN = 1;
const unsigned char *titlebgallArray[1] = {
    titlebgbackground};

void setup()
{
  display.begin(SSD1306_SWITCHCAPVCC, SCREEN_ADDRESS);
  display.display(); // バッファの初期値（adafruitのロゴ）を表示
  delay(2000);

  // 乱数のシード設定
  randomSeed(500);
  sframe = millis(); // 現在時刻を取得
  frameCounter = 20;
}

void loop()
{

  display.clearDisplay(); // ディスプレイのバッファを初期化
  getStickStateXY();

  switch (gameState)
  {
  case inGameStart:
    gameStartProcess();
    break;
  case inGameNow:
    inGameProcess();
    inGameScoreBoard();
    break;
  case inGameEnd:
    endGameProcess();
    inGameScoreBoard();
    break;
  case inResult:
    resultScreen();
    break;

  default: // title
    titleScreen();
    break;
  }
  // display.display();
  FrameTimer();
  display.display();
}

void titleScreen()
{
  display.drawBitmap(0, 0, titlebgbackground, (uint8_t)SCREEN_WIDTH, (int16_t)SCREEN_HEIGHT, WHITE);
  display.setCursor(4, 28);
  display.setTextColor(SSD1306_WHITE);
  display.setTextSize(1);
  display.print("BESTSCORE");
  display.setCursor(15, 40);
  display.print(bestScore);
  display.setCursor(10, 52);
  display.print("-> PLAY");
  if (frameCounter > 0)
  {
    frameCounter--;
  }
  else if (xStickState > 1)
  {
    display.fillRect(8, 50, 46, 12, INVERSE);
    display.display();
    delay(1000);
    gameState = inGameStart;
  }
}

void resultScreen()
{
  display.drawBitmap(0, 0, titlebgbackground, (uint8_t)SCREEN_WIDTH, (int16_t)SCREEN_HEIGHT, WHITE);
  display.setTextSize(1);
  display.setCursor(4, 28);
  display.print("GAME OVER!");
  display.setCursor(4, 40);
  display.print(score);
  display.setCursor(10, 52);
  display.print("-> TITLE");
  if (frameCounter > 0)
  {
    frameCounter--;
  }
  else if (xStickState > 1)
  {
    display.fillRect(8, 50, 52, 12, INVERSE);
    display.display();
    delay(1000);
    gameState = inTitle;
    frameCounter = 20;
  }
}

void FrameTimer()
{                                // 周期処理用に処理を遅延させるメソッド
  unsigned long curr = millis(); // 現在時刻を取得
  if (curr - sframe > frame_ms)
  { // 現在時刻がフレーム管理時計を超えていたら何らかのアラートを出す
    // この例では処理落ち表示
    // display.setCursor(0,56);
    // display.print("SHORIOCHI");
    sframe = millis(); // 現在時刻を取得
  }
  else
  {
    // 余剰時間を消化する処理。時間がオーバーしていたらこの処理を自然と飛ばす。
    while (curr - sframe < frame_ms)
    {
      curr = millis();
    }
    sframe = curr;
  }
}
/*テスト用loop関数
void loop(){
  getStickStateXY();
  display.clearDisplay(); // ディスプレイのバッファを初期化
  display.setTextSize(1); // テキストサイズ1(6x8), 2(12x16)
  display.setTextColor(SSD1306_WHITE); // テキストの色
  display.setCursor(0, 0); // カーソルの位置（X=0, Y=0）
  display.print("X"); // 文字を描画
  display.print(stickX); // 文字を描画
  display.println(xStickState);
  display.print("Y"); // 文字を描画
  display.print(stickY); // 文字を描画
  display.println(yStickState);

  display.drawLine(0, 10, 128, 10, WHITE); // 線を描画
  display.print(gameState);
  display.display(); // ディスプレイのバッファを表示
}*/

// スティックの状態を取得
void getStickStateXY()
{
  // 生の値
  stickX = -1 * analogRead(pinX) + 512;
  stickY = analogRead(pinY) - 512;
  // 5段階評価
  xStickState = getStickState(stickX);
  yStickState = getStickState(stickY);
}

// スティックの状態の5段階評価の関数
int8_t getStickState(int value)
{
  int8_t tmpState = 0; // 中心付近のとき0
  if (abs(value) > 430)
  {
    tmpState = 2; // 値が大きいとき2
  }
  else if (abs(value) > 120)
  {
    tmpState = 1; // 値が小さいと1
  }
  if (value < 0)
  { // 値が負のときマイナスに
    tmpState = tmpState * -1;
  }
  return tmpState;
}

// ゲームの処理
void inGameProcess()
{
  // clearBuffers(pixelsBuffer);
  generateBullets();

  // display.setCursor(0, DefaultCursorY); // カーソルの位置（X=10, Y=0）
  // 弾の処理
  for (uint8_t cnt = 0; cnt < MaxBullets; cnt++)
  {
    bullet[cnt].update();
  }
  player.update();
}

// ゲーム開始時の処理
void gameStartProcess()
{
  score = 0;
  player.start();
  gameState = inGameNow;
}

void endGameProcess()
{
  for (uint8_t cnt = 0; cnt < MaxBullets; cnt++)
  {
    bullet[cnt].update();
  }
  player.endAnimator();
}

// TextSize(1)…縦8,横6 bit
// スコア表示の処理
void inGameScoreBoard()
{
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE); // テキストの色
#define scoreketasuu 5
  display.setCursor(8, 0);
  display.println("SCORE:");
  display.setCursor(42 + (6 * scoreketasuu) - (6 * keta(score)), 0); // 5桁ぶんの領域を確保し、スコアを右揃えに
  display.print(score);                                              // スコア表示
  display.setCursor(42 + (6 * scoreketasuu) + 8, 0);                 // カーソル移動
  display.print("HEALTH:");
  display.print((int)player.health); // 体力表示
  display.drawLine(0, 8, 128, 8, WHITE);
}

// スコアの桁数を返す関数
int8_t keta(uint16_t tmpScore)
{
  int8_t cnt = 0; // 桁数カウンタ
  /*if(tmpScore < 0){ //スコアが0以下のときの処理(使わない)
    cnt++;
    tmpScore = -1 * tmpScore;
  }*/
  do
  {
    cnt++;
    tmpScore = tmpScore / 10; // tmpScoreが0～9のときtmpScoreが0に
    if (tmpScore == 0)
    {
      return cnt; // 桁数を返す
    }
  } while (tmpScore > 0);
}

// 弾カウンタのリセット
uint8_t resetBulletNumber(uint8_t value)
{
  if (value >= 8)
  {
    return 0;
  }
}

// スコア表示テスト用関数
void scoreTest()
{
  if (xStickState == 2)
  {
    addScore(100);
  }
}

// 弾生成
void generateBullets()
{
  for (bulletNumber = 0; bulletNumber < MaxBullets; bulletNumber++)
  { // 有効でないbulletを探す
    if (bullet[bulletNumber].isActive == false)
    {                                        // 有効でないbulletを見つけたとき
      bullet[bulletNumber].activateBullet(); // 弾を有効にする
      break;
    }
  }
}

// 表示関連

// バッファ配列をクリア
/*
void clearBuffers(uint8_t buffer[128][54]){
  for(uint8_t cnt1 = 0;cnt1 < 128;cnt1++){
    for(uint8_t cnt2 = 0;cnt2 < 55;cnt2++){
      buffer[cnt1][cnt2]=0;
    }
  }
}*/

//  stickX = -1 * analogRead(pinX) + 1023;
//  stickY = analogRead(pinY);

/*
void titleScreen(){

}

struct bullet{

}*/